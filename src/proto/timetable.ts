// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.3
// source: src/proto/timetable.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty";

export const protobufPackage = "timetable";

export interface PostUpdateTimetable {
  periods: PeriodsData | undefined;
  subjects: SubjectsData | undefined;
  teachers: TeachersData | undefined;
  classrooms: ClassroomsData | undefined;
  classes: ClassesData | undefined;
  groups: GroupsData | undefined;
  lessons: LessonsData | undefined;
  cards: CardsData | undefined;
}

export interface PeriodsData {
  period: PeriodArray[];
}

export interface SubjectsData {
  subject: SubjectArray[];
}

export interface TeachersData {
  teacher: TeacherArray[];
}

export interface ClassroomsData {
  classroom: ClassroomArray[];
}

export interface ClassesData {
  class: ClassArray[];
}

export interface GroupsData {
  group: GroupArray[];
}

export interface LessonsData {
  lesson: LessonArray[];
}

export interface CardsData {
  card: CardArray[];
}

export interface PeriodArray {
  name: string;
  short: string;
  period: string;
  starttime: string;
  endtime: string;
}

export interface SubjectArray {
  id: string;
  name: string;
  short: string;
  partnerId: string;
}

export interface TeacherArray {
  id: string;
  name: string;
  short: string;
  gender: string;
  color: string;
  email: string;
  mobile: string;
  partnerId: string;
  firstname: string;
  lastname: string;
}

export interface ClassroomArray {
  id: string;
  name: string;
  short: string;
  capacity: string;
  buildingid: string;
  partnerId: string;
}

export interface ClassArray {
  id: string;
  name: string;
  short: string;
  classroomids: string;
  teacherid: string;
  grade: string;
  partnerId: string;
}

export interface GroupArray {
  id: string;
  name: string;
  classid: string;
}

export interface LessonArray {
  id: string;
  classids: string;
  subjectid: string;
  teacherids: string;
  classroomids: string;
  groupids: string;
  periodspercard: string;
  periodsperweek: string;
  capacity: string;
  seminargroup: string;
  termsdefid: string;
  weeksdefid: string;
  daysdefid: string;
  partnerId: string;
}

export interface CardArray {
  lessonid: string;
  period: string;
  weeks: string;
  days: string;
  terms: string;
  classroomids: string;
}

function createBasePostUpdateTimetable(): PostUpdateTimetable {
  return {
    periods: undefined,
    subjects: undefined,
    teachers: undefined,
    classrooms: undefined,
    classes: undefined,
    groups: undefined,
    lessons: undefined,
    cards: undefined,
  };
}

export const PostUpdateTimetable = {
  encode(message: PostUpdateTimetable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.periods !== undefined) {
      PeriodsData.encode(message.periods, writer.uint32(10).fork()).ldelim();
    }
    if (message.subjects !== undefined) {
      SubjectsData.encode(message.subjects, writer.uint32(18).fork()).ldelim();
    }
    if (message.teachers !== undefined) {
      TeachersData.encode(message.teachers, writer.uint32(26).fork()).ldelim();
    }
    if (message.classrooms !== undefined) {
      ClassroomsData.encode(message.classrooms, writer.uint32(34).fork()).ldelim();
    }
    if (message.classes !== undefined) {
      ClassesData.encode(message.classes, writer.uint32(42).fork()).ldelim();
    }
    if (message.groups !== undefined) {
      GroupsData.encode(message.groups, writer.uint32(50).fork()).ldelim();
    }
    if (message.lessons !== undefined) {
      LessonsData.encode(message.lessons, writer.uint32(58).fork()).ldelim();
    }
    if (message.cards !== undefined) {
      CardsData.encode(message.cards, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PostUpdateTimetable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostUpdateTimetable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.periods = PeriodsData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subjects = SubjectsData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teachers = TeachersData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classrooms = ClassroomsData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classes = ClassesData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.groups = GroupsData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lessons = LessonsData.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cards = CardsData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostUpdateTimetable {
    return {
      periods: isSet(object.periods) ? PeriodsData.fromJSON(object.periods) : undefined,
      subjects: isSet(object.subjects) ? SubjectsData.fromJSON(object.subjects) : undefined,
      teachers: isSet(object.teachers) ? TeachersData.fromJSON(object.teachers) : undefined,
      classrooms: isSet(object.classrooms) ? ClassroomsData.fromJSON(object.classrooms) : undefined,
      classes: isSet(object.classes) ? ClassesData.fromJSON(object.classes) : undefined,
      groups: isSet(object.groups) ? GroupsData.fromJSON(object.groups) : undefined,
      lessons: isSet(object.lessons) ? LessonsData.fromJSON(object.lessons) : undefined,
      cards: isSet(object.cards) ? CardsData.fromJSON(object.cards) : undefined,
    };
  },

  toJSON(message: PostUpdateTimetable): unknown {
    const obj: any = {};
    if (message.periods !== undefined) {
      obj.periods = PeriodsData.toJSON(message.periods);
    }
    if (message.subjects !== undefined) {
      obj.subjects = SubjectsData.toJSON(message.subjects);
    }
    if (message.teachers !== undefined) {
      obj.teachers = TeachersData.toJSON(message.teachers);
    }
    if (message.classrooms !== undefined) {
      obj.classrooms = ClassroomsData.toJSON(message.classrooms);
    }
    if (message.classes !== undefined) {
      obj.classes = ClassesData.toJSON(message.classes);
    }
    if (message.groups !== undefined) {
      obj.groups = GroupsData.toJSON(message.groups);
    }
    if (message.lessons !== undefined) {
      obj.lessons = LessonsData.toJSON(message.lessons);
    }
    if (message.cards !== undefined) {
      obj.cards = CardsData.toJSON(message.cards);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostUpdateTimetable>, I>>(base?: I): PostUpdateTimetable {
    return PostUpdateTimetable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostUpdateTimetable>, I>>(object: I): PostUpdateTimetable {
    const message = createBasePostUpdateTimetable();
    message.periods = (object.periods !== undefined && object.periods !== null)
      ? PeriodsData.fromPartial(object.periods)
      : undefined;
    message.subjects = (object.subjects !== undefined && object.subjects !== null)
      ? SubjectsData.fromPartial(object.subjects)
      : undefined;
    message.teachers = (object.teachers !== undefined && object.teachers !== null)
      ? TeachersData.fromPartial(object.teachers)
      : undefined;
    message.classrooms = (object.classrooms !== undefined && object.classrooms !== null)
      ? ClassroomsData.fromPartial(object.classrooms)
      : undefined;
    message.classes = (object.classes !== undefined && object.classes !== null)
      ? ClassesData.fromPartial(object.classes)
      : undefined;
    message.groups = (object.groups !== undefined && object.groups !== null)
      ? GroupsData.fromPartial(object.groups)
      : undefined;
    message.lessons = (object.lessons !== undefined && object.lessons !== null)
      ? LessonsData.fromPartial(object.lessons)
      : undefined;
    message.cards = (object.cards !== undefined && object.cards !== null)
      ? CardsData.fromPartial(object.cards)
      : undefined;
    return message;
  },
};

function createBasePeriodsData(): PeriodsData {
  return { period: [] };
}

export const PeriodsData = {
  encode(message: PeriodsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.period) {
      PeriodArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PeriodsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriodsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.period.push(PeriodArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeriodsData {
    return {
      period: globalThis.Array.isArray(object?.period) ? object.period.map((e: any) => PeriodArray.fromJSON(e)) : [],
    };
  },

  toJSON(message: PeriodsData): unknown {
    const obj: any = {};
    if (message.period?.length) {
      obj.period = message.period.map((e) => PeriodArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeriodsData>, I>>(base?: I): PeriodsData {
    return PeriodsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeriodsData>, I>>(object: I): PeriodsData {
    const message = createBasePeriodsData();
    message.period = object.period?.map((e) => PeriodArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubjectsData(): SubjectsData {
  return { subject: [] };
}

export const SubjectsData = {
  encode(message: SubjectsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subject) {
      SubjectArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubjectsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject.push(SubjectArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectsData {
    return {
      subject: globalThis.Array.isArray(object?.subject)
        ? object.subject.map((e: any) => SubjectArray.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubjectsData): unknown {
    const obj: any = {};
    if (message.subject?.length) {
      obj.subject = message.subject.map((e) => SubjectArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubjectsData>, I>>(base?: I): SubjectsData {
    return SubjectsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubjectsData>, I>>(object: I): SubjectsData {
    const message = createBaseSubjectsData();
    message.subject = object.subject?.map((e) => SubjectArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTeachersData(): TeachersData {
  return { teacher: [] };
}

export const TeachersData = {
  encode(message: TeachersData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.teacher) {
      TeacherArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeachersData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeachersData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teacher.push(TeacherArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeachersData {
    return {
      teacher: globalThis.Array.isArray(object?.teacher)
        ? object.teacher.map((e: any) => TeacherArray.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TeachersData): unknown {
    const obj: any = {};
    if (message.teacher?.length) {
      obj.teacher = message.teacher.map((e) => TeacherArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeachersData>, I>>(base?: I): TeachersData {
    return TeachersData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeachersData>, I>>(object: I): TeachersData {
    const message = createBaseTeachersData();
    message.teacher = object.teacher?.map((e) => TeacherArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClassroomsData(): ClassroomsData {
  return { classroom: [] };
}

export const ClassroomsData = {
  encode(message: ClassroomsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.classroom) {
      ClassroomArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassroomsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassroomsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.classroom.push(ClassroomArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassroomsData {
    return {
      classroom: globalThis.Array.isArray(object?.classroom)
        ? object.classroom.map((e: any) => ClassroomArray.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClassroomsData): unknown {
    const obj: any = {};
    if (message.classroom?.length) {
      obj.classroom = message.classroom.map((e) => ClassroomArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassroomsData>, I>>(base?: I): ClassroomsData {
    return ClassroomsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassroomsData>, I>>(object: I): ClassroomsData {
    const message = createBaseClassroomsData();
    message.classroom = object.classroom?.map((e) => ClassroomArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClassesData(): ClassesData {
  return { class: [] };
}

export const ClassesData = {
  encode(message: ClassesData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.class) {
      ClassArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassesData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.class.push(ClassArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassesData {
    return {
      class: globalThis.Array.isArray(object?.class) ? object.class.map((e: any) => ClassArray.fromJSON(e)) : [],
    };
  },

  toJSON(message: ClassesData): unknown {
    const obj: any = {};
    if (message.class?.length) {
      obj.class = message.class.map((e) => ClassArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassesData>, I>>(base?: I): ClassesData {
    return ClassesData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassesData>, I>>(object: I): ClassesData {
    const message = createBaseClassesData();
    message.class = object.class?.map((e) => ClassArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupsData(): GroupsData {
  return { group: [] };
}

export const GroupsData = {
  encode(message: GroupsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.group) {
      GroupArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group.push(GroupArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupsData {
    return {
      group: globalThis.Array.isArray(object?.group) ? object.group.map((e: any) => GroupArray.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupsData): unknown {
    const obj: any = {};
    if (message.group?.length) {
      obj.group = message.group.map((e) => GroupArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupsData>, I>>(base?: I): GroupsData {
    return GroupsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupsData>, I>>(object: I): GroupsData {
    const message = createBaseGroupsData();
    message.group = object.group?.map((e) => GroupArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLessonsData(): LessonsData {
  return { lesson: [] };
}

export const LessonsData = {
  encode(message: LessonsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lesson) {
      LessonArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LessonsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLessonsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lesson.push(LessonArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LessonsData {
    return {
      lesson: globalThis.Array.isArray(object?.lesson) ? object.lesson.map((e: any) => LessonArray.fromJSON(e)) : [],
    };
  },

  toJSON(message: LessonsData): unknown {
    const obj: any = {};
    if (message.lesson?.length) {
      obj.lesson = message.lesson.map((e) => LessonArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LessonsData>, I>>(base?: I): LessonsData {
    return LessonsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LessonsData>, I>>(object: I): LessonsData {
    const message = createBaseLessonsData();
    message.lesson = object.lesson?.map((e) => LessonArray.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCardsData(): CardsData {
  return { card: [] };
}

export const CardsData = {
  encode(message: CardsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.card) {
      CardArray.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CardsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.card.push(CardArray.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardsData {
    return { card: globalThis.Array.isArray(object?.card) ? object.card.map((e: any) => CardArray.fromJSON(e)) : [] };
  },

  toJSON(message: CardsData): unknown {
    const obj: any = {};
    if (message.card?.length) {
      obj.card = message.card.map((e) => CardArray.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CardsData>, I>>(base?: I): CardsData {
    return CardsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CardsData>, I>>(object: I): CardsData {
    const message = createBaseCardsData();
    message.card = object.card?.map((e) => CardArray.fromPartial(e)) || [];
    return message;
  },
};

function createBasePeriodArray(): PeriodArray {
  return { name: "", short: "", period: "", starttime: "", endtime: "" };
}

export const PeriodArray = {
  encode(message: PeriodArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.short !== "") {
      writer.uint32(18).string(message.short);
    }
    if (message.period !== "") {
      writer.uint32(26).string(message.period);
    }
    if (message.starttime !== "") {
      writer.uint32(34).string(message.starttime);
    }
    if (message.endtime !== "") {
      writer.uint32(42).string(message.endtime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PeriodArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriodArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.short = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.period = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.starttime = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endtime = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeriodArray {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      short: isSet(object.short) ? globalThis.String(object.short) : "",
      period: isSet(object.period) ? globalThis.String(object.period) : "",
      starttime: isSet(object.starttime) ? globalThis.String(object.starttime) : "",
      endtime: isSet(object.endtime) ? globalThis.String(object.endtime) : "",
    };
  },

  toJSON(message: PeriodArray): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.short !== "") {
      obj.short = message.short;
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    if (message.starttime !== "") {
      obj.starttime = message.starttime;
    }
    if (message.endtime !== "") {
      obj.endtime = message.endtime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeriodArray>, I>>(base?: I): PeriodArray {
    return PeriodArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeriodArray>, I>>(object: I): PeriodArray {
    const message = createBasePeriodArray();
    message.name = object.name ?? "";
    message.short = object.short ?? "";
    message.period = object.period ?? "";
    message.starttime = object.starttime ?? "";
    message.endtime = object.endtime ?? "";
    return message;
  },
};

function createBaseSubjectArray(): SubjectArray {
  return { id: "", name: "", short: "", partnerId: "" };
}

export const SubjectArray = {
  encode(message: SubjectArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.short !== "") {
      writer.uint32(26).string(message.short);
    }
    if (message.partnerId !== "") {
      writer.uint32(34).string(message.partnerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubjectArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.short = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partnerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      short: isSet(object.short) ? globalThis.String(object.short) : "",
      partnerId: isSet(object.partnerId) ? globalThis.String(object.partnerId) : "",
    };
  },

  toJSON(message: SubjectArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.short !== "") {
      obj.short = message.short;
    }
    if (message.partnerId !== "") {
      obj.partnerId = message.partnerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubjectArray>, I>>(base?: I): SubjectArray {
    return SubjectArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubjectArray>, I>>(object: I): SubjectArray {
    const message = createBaseSubjectArray();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.short = object.short ?? "";
    message.partnerId = object.partnerId ?? "";
    return message;
  },
};

function createBaseTeacherArray(): TeacherArray {
  return {
    id: "",
    name: "",
    short: "",
    gender: "",
    color: "",
    email: "",
    mobile: "",
    partnerId: "",
    firstname: "",
    lastname: "",
  };
}

export const TeacherArray = {
  encode(message: TeacherArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.short !== "") {
      writer.uint32(26).string(message.short);
    }
    if (message.gender !== "") {
      writer.uint32(34).string(message.gender);
    }
    if (message.color !== "") {
      writer.uint32(42).string(message.color);
    }
    if (message.email !== "") {
      writer.uint32(50).string(message.email);
    }
    if (message.mobile !== "") {
      writer.uint32(58).string(message.mobile);
    }
    if (message.partnerId !== "") {
      writer.uint32(66).string(message.partnerId);
    }
    if (message.firstname !== "") {
      writer.uint32(74).string(message.firstname);
    }
    if (message.lastname !== "") {
      writer.uint32(82).string(message.lastname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeacherArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeacherArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.short = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gender = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.color = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.email = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mobile = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.partnerId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.firstname = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeacherArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      short: isSet(object.short) ? globalThis.String(object.short) : "",
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      mobile: isSet(object.mobile) ? globalThis.String(object.mobile) : "",
      partnerId: isSet(object.partnerId) ? globalThis.String(object.partnerId) : "",
      firstname: isSet(object.firstname) ? globalThis.String(object.firstname) : "",
      lastname: isSet(object.lastname) ? globalThis.String(object.lastname) : "",
    };
  },

  toJSON(message: TeacherArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.short !== "") {
      obj.short = message.short;
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.mobile !== "") {
      obj.mobile = message.mobile;
    }
    if (message.partnerId !== "") {
      obj.partnerId = message.partnerId;
    }
    if (message.firstname !== "") {
      obj.firstname = message.firstname;
    }
    if (message.lastname !== "") {
      obj.lastname = message.lastname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeacherArray>, I>>(base?: I): TeacherArray {
    return TeacherArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeacherArray>, I>>(object: I): TeacherArray {
    const message = createBaseTeacherArray();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.short = object.short ?? "";
    message.gender = object.gender ?? "";
    message.color = object.color ?? "";
    message.email = object.email ?? "";
    message.mobile = object.mobile ?? "";
    message.partnerId = object.partnerId ?? "";
    message.firstname = object.firstname ?? "";
    message.lastname = object.lastname ?? "";
    return message;
  },
};

function createBaseClassroomArray(): ClassroomArray {
  return { id: "", name: "", short: "", capacity: "", buildingid: "", partnerId: "" };
}

export const ClassroomArray = {
  encode(message: ClassroomArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.short !== "") {
      writer.uint32(26).string(message.short);
    }
    if (message.capacity !== "") {
      writer.uint32(34).string(message.capacity);
    }
    if (message.buildingid !== "") {
      writer.uint32(42).string(message.buildingid);
    }
    if (message.partnerId !== "") {
      writer.uint32(50).string(message.partnerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassroomArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassroomArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.short = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capacity = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.buildingid = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.partnerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassroomArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      short: isSet(object.short) ? globalThis.String(object.short) : "",
      capacity: isSet(object.capacity) ? globalThis.String(object.capacity) : "",
      buildingid: isSet(object.buildingid) ? globalThis.String(object.buildingid) : "",
      partnerId: isSet(object.partnerId) ? globalThis.String(object.partnerId) : "",
    };
  },

  toJSON(message: ClassroomArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.short !== "") {
      obj.short = message.short;
    }
    if (message.capacity !== "") {
      obj.capacity = message.capacity;
    }
    if (message.buildingid !== "") {
      obj.buildingid = message.buildingid;
    }
    if (message.partnerId !== "") {
      obj.partnerId = message.partnerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassroomArray>, I>>(base?: I): ClassroomArray {
    return ClassroomArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassroomArray>, I>>(object: I): ClassroomArray {
    const message = createBaseClassroomArray();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.short = object.short ?? "";
    message.capacity = object.capacity ?? "";
    message.buildingid = object.buildingid ?? "";
    message.partnerId = object.partnerId ?? "";
    return message;
  },
};

function createBaseClassArray(): ClassArray {
  return { id: "", name: "", short: "", classroomids: "", teacherid: "", grade: "", partnerId: "" };
}

export const ClassArray = {
  encode(message: ClassArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.short !== "") {
      writer.uint32(26).string(message.short);
    }
    if (message.classroomids !== "") {
      writer.uint32(34).string(message.classroomids);
    }
    if (message.teacherid !== "") {
      writer.uint32(42).string(message.teacherid);
    }
    if (message.grade !== "") {
      writer.uint32(50).string(message.grade);
    }
    if (message.partnerId !== "") {
      writer.uint32(58).string(message.partnerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.short = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classroomids = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teacherid = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.grade = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.partnerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      short: isSet(object.short) ? globalThis.String(object.short) : "",
      classroomids: isSet(object.classroomids) ? globalThis.String(object.classroomids) : "",
      teacherid: isSet(object.teacherid) ? globalThis.String(object.teacherid) : "",
      grade: isSet(object.grade) ? globalThis.String(object.grade) : "",
      partnerId: isSet(object.partnerId) ? globalThis.String(object.partnerId) : "",
    };
  },

  toJSON(message: ClassArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.short !== "") {
      obj.short = message.short;
    }
    if (message.classroomids !== "") {
      obj.classroomids = message.classroomids;
    }
    if (message.teacherid !== "") {
      obj.teacherid = message.teacherid;
    }
    if (message.grade !== "") {
      obj.grade = message.grade;
    }
    if (message.partnerId !== "") {
      obj.partnerId = message.partnerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassArray>, I>>(base?: I): ClassArray {
    return ClassArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassArray>, I>>(object: I): ClassArray {
    const message = createBaseClassArray();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.short = object.short ?? "";
    message.classroomids = object.classroomids ?? "";
    message.teacherid = object.teacherid ?? "";
    message.grade = object.grade ?? "";
    message.partnerId = object.partnerId ?? "";
    return message;
  },
};

function createBaseGroupArray(): GroupArray {
  return { id: "", name: "", classid: "" };
}

export const GroupArray = {
  encode(message: GroupArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.classid !== "") {
      writer.uint32(26).string(message.classid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.classid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      classid: isSet(object.classid) ? globalThis.String(object.classid) : "",
    };
  },

  toJSON(message: GroupArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.classid !== "") {
      obj.classid = message.classid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupArray>, I>>(base?: I): GroupArray {
    return GroupArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupArray>, I>>(object: I): GroupArray {
    const message = createBaseGroupArray();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.classid = object.classid ?? "";
    return message;
  },
};

function createBaseLessonArray(): LessonArray {
  return {
    id: "",
    classids: "",
    subjectid: "",
    teacherids: "",
    classroomids: "",
    groupids: "",
    periodspercard: "",
    periodsperweek: "",
    capacity: "",
    seminargroup: "",
    termsdefid: "",
    weeksdefid: "",
    daysdefid: "",
    partnerId: "",
  };
}

export const LessonArray = {
  encode(message: LessonArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.classids !== "") {
      writer.uint32(18).string(message.classids);
    }
    if (message.subjectid !== "") {
      writer.uint32(26).string(message.subjectid);
    }
    if (message.teacherids !== "") {
      writer.uint32(34).string(message.teacherids);
    }
    if (message.classroomids !== "") {
      writer.uint32(42).string(message.classroomids);
    }
    if (message.groupids !== "") {
      writer.uint32(50).string(message.groupids);
    }
    if (message.periodspercard !== "") {
      writer.uint32(58).string(message.periodspercard);
    }
    if (message.periodsperweek !== "") {
      writer.uint32(66).string(message.periodsperweek);
    }
    if (message.capacity !== "") {
      writer.uint32(74).string(message.capacity);
    }
    if (message.seminargroup !== "") {
      writer.uint32(82).string(message.seminargroup);
    }
    if (message.termsdefid !== "") {
      writer.uint32(90).string(message.termsdefid);
    }
    if (message.weeksdefid !== "") {
      writer.uint32(98).string(message.weeksdefid);
    }
    if (message.daysdefid !== "") {
      writer.uint32(106).string(message.daysdefid);
    }
    if (message.partnerId !== "") {
      writer.uint32(114).string(message.partnerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LessonArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLessonArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classids = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subjectid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.teacherids = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classroomids = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.groupids = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.periodspercard = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.periodsperweek = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.capacity = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.seminargroup = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.termsdefid = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.weeksdefid = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.daysdefid = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.partnerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LessonArray {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      classids: isSet(object.classids) ? globalThis.String(object.classids) : "",
      subjectid: isSet(object.subjectid) ? globalThis.String(object.subjectid) : "",
      teacherids: isSet(object.teacherids) ? globalThis.String(object.teacherids) : "",
      classroomids: isSet(object.classroomids) ? globalThis.String(object.classroomids) : "",
      groupids: isSet(object.groupids) ? globalThis.String(object.groupids) : "",
      periodspercard: isSet(object.periodspercard) ? globalThis.String(object.periodspercard) : "",
      periodsperweek: isSet(object.periodsperweek) ? globalThis.String(object.periodsperweek) : "",
      capacity: isSet(object.capacity) ? globalThis.String(object.capacity) : "",
      seminargroup: isSet(object.seminargroup) ? globalThis.String(object.seminargroup) : "",
      termsdefid: isSet(object.termsdefid) ? globalThis.String(object.termsdefid) : "",
      weeksdefid: isSet(object.weeksdefid) ? globalThis.String(object.weeksdefid) : "",
      daysdefid: isSet(object.daysdefid) ? globalThis.String(object.daysdefid) : "",
      partnerId: isSet(object.partnerId) ? globalThis.String(object.partnerId) : "",
    };
  },

  toJSON(message: LessonArray): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.classids !== "") {
      obj.classids = message.classids;
    }
    if (message.subjectid !== "") {
      obj.subjectid = message.subjectid;
    }
    if (message.teacherids !== "") {
      obj.teacherids = message.teacherids;
    }
    if (message.classroomids !== "") {
      obj.classroomids = message.classroomids;
    }
    if (message.groupids !== "") {
      obj.groupids = message.groupids;
    }
    if (message.periodspercard !== "") {
      obj.periodspercard = message.periodspercard;
    }
    if (message.periodsperweek !== "") {
      obj.periodsperweek = message.periodsperweek;
    }
    if (message.capacity !== "") {
      obj.capacity = message.capacity;
    }
    if (message.seminargroup !== "") {
      obj.seminargroup = message.seminargroup;
    }
    if (message.termsdefid !== "") {
      obj.termsdefid = message.termsdefid;
    }
    if (message.weeksdefid !== "") {
      obj.weeksdefid = message.weeksdefid;
    }
    if (message.daysdefid !== "") {
      obj.daysdefid = message.daysdefid;
    }
    if (message.partnerId !== "") {
      obj.partnerId = message.partnerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LessonArray>, I>>(base?: I): LessonArray {
    return LessonArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LessonArray>, I>>(object: I): LessonArray {
    const message = createBaseLessonArray();
    message.id = object.id ?? "";
    message.classids = object.classids ?? "";
    message.subjectid = object.subjectid ?? "";
    message.teacherids = object.teacherids ?? "";
    message.classroomids = object.classroomids ?? "";
    message.groupids = object.groupids ?? "";
    message.periodspercard = object.periodspercard ?? "";
    message.periodsperweek = object.periodsperweek ?? "";
    message.capacity = object.capacity ?? "";
    message.seminargroup = object.seminargroup ?? "";
    message.termsdefid = object.termsdefid ?? "";
    message.weeksdefid = object.weeksdefid ?? "";
    message.daysdefid = object.daysdefid ?? "";
    message.partnerId = object.partnerId ?? "";
    return message;
  },
};

function createBaseCardArray(): CardArray {
  return { lessonid: "", period: "", weeks: "", days: "", terms: "", classroomids: "" };
}

export const CardArray = {
  encode(message: CardArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lessonid !== "") {
      writer.uint32(10).string(message.lessonid);
    }
    if (message.period !== "") {
      writer.uint32(18).string(message.period);
    }
    if (message.weeks !== "") {
      writer.uint32(26).string(message.weeks);
    }
    if (message.days !== "") {
      writer.uint32(34).string(message.days);
    }
    if (message.terms !== "") {
      writer.uint32(42).string(message.terms);
    }
    if (message.classroomids !== "") {
      writer.uint32(50).string(message.classroomids);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CardArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lessonid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.period = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.weeks = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.days = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.terms = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.classroomids = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardArray {
    return {
      lessonid: isSet(object.lessonid) ? globalThis.String(object.lessonid) : "",
      period: isSet(object.period) ? globalThis.String(object.period) : "",
      weeks: isSet(object.weeks) ? globalThis.String(object.weeks) : "",
      days: isSet(object.days) ? globalThis.String(object.days) : "",
      terms: isSet(object.terms) ? globalThis.String(object.terms) : "",
      classroomids: isSet(object.classroomids) ? globalThis.String(object.classroomids) : "",
    };
  },

  toJSON(message: CardArray): unknown {
    const obj: any = {};
    if (message.lessonid !== "") {
      obj.lessonid = message.lessonid;
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    if (message.weeks !== "") {
      obj.weeks = message.weeks;
    }
    if (message.days !== "") {
      obj.days = message.days;
    }
    if (message.terms !== "") {
      obj.terms = message.terms;
    }
    if (message.classroomids !== "") {
      obj.classroomids = message.classroomids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CardArray>, I>>(base?: I): CardArray {
    return CardArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CardArray>, I>>(object: I): CardArray {
    const message = createBaseCardArray();
    message.lessonid = object.lessonid ?? "";
    message.period = object.period ?? "";
    message.weeks = object.weeks ?? "";
    message.days = object.days ?? "";
    message.terms = object.terms ?? "";
    message.classroomids = object.classroomids ?? "";
    return message;
  },
};

export interface UpdateTimetableListener {
  UpdateTimetable(request: PostUpdateTimetable): Promise<Empty>;
}

export const UpdateTimetableListenerServiceName = "timetable.UpdateTimetableListener";
export class UpdateTimetableListenerClientImpl implements UpdateTimetableListener {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UpdateTimetableListenerServiceName;
    this.rpc = rpc;
    this.UpdateTimetable = this.UpdateTimetable.bind(this);
  }
  UpdateTimetable(request: PostUpdateTimetable): Promise<Empty> {
    const data = PostUpdateTimetable.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTimetable", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
